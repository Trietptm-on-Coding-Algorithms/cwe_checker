use crate::bil::*;
use serde::{Deserialize, Serialize};
use std::cmp::Ordering;
use apint::Width;
use std::sync::Arc;
use std::ops::Deref;

/// The main trait describing an abstract domain.
///
/// Each abstract domain is partially ordered and has a maximal element (which can be generated by `top()`).
/// Abstract domains of the same type can be merged.
///
/// TODO: Decide if and how to represent intersects and bottom values!
pub trait AbstractDomain: Sized + Eq + Clone {
    /// The maximal value of a domain.
    /// Usually it indicates a value for which nothing is known.
    fn top(&self) -> Self;

    fn merge(&self, other: &Self) -> Self {
        if self == other {
            self.clone()
        } else {
            self.top()
        }
    }
}

/// A trait for abstract domains that represent values that can be loaded into register or written onto the stack.
/// Every value has a determined and immutable length (in bits).
pub trait ValueDomain: AbstractDomain {
    /// Returns the size of the value in bits
    fn bitsize(&self) -> BitSize;

    /// Return a new top element with the given bitsize
    fn new_top(bitsize: BitSize) -> Self;
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash, Clone)]
pub enum BitvectorDomain {
    Top(BitSize),
    Value(Bitvector),
    Bottom(BitSize),
}

impl ValueDomain for BitvectorDomain {
    fn bitsize(&self) -> BitSize {
        use BitvectorDomain::*;
        match self {
            Top(bitsize) | Bottom(bitsize) => *bitsize,
            Value(bitvec) => bitvec.width().to_usize() as u16
        }
    }

    fn new_top(bitsize: BitSize) -> BitvectorDomain {
        BitvectorDomain::Top(bitsize)
    }
}


/// TODO: Decide whether to remove the implementation, since it is not needed
impl PartialOrd for BitvectorDomain {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        use BitvectorDomain::*;
        match (self, other) {
            (Top(x), Top(y)) => {
                if x == y {
                    Some(Ordering::Equal)
                } else {
                    None
                }
            }
            (Value(x), Value(y)) => {
                if x == y {
                    Some(Ordering::Equal)
                } else {
                    None
                }
            }
            (Bottom(x), Bottom(y)) => {
                if x == y {
                    Some(Ordering::Equal)
                } else {
                    None
                }
            }
            (Top(_), _) => Some(Ordering::Greater),
            (_, Top(_)) => Some(Ordering::Less),
            (Value(_), _) => Some(Ordering::Greater),
            (_, Value(_)) => Some(Ordering::Less),
        }
    }
}

impl AbstractDomain for BitvectorDomain {
    fn top(&self) -> BitvectorDomain {
        BitvectorDomain::Top(self.bitsize())
    }
}

#[derive(Serialize, Deserialize, Debug, Hash, Clone)]
pub struct FastCmpArc<T>(pub Arc<T>);

impl<T: PartialEq + Eq> PartialEq for FastCmpArc<T> {
    fn eq(&self, other:&Self) -> bool {
        if Arc::ptr_eq(&self.0, &other.0) {
            true
        } else {
            self.eq(other)
        }
    }
}

impl<T: Eq> Eq for FastCmpArc<T> {}

impl<T: AbstractDomain + Clone> AbstractDomain for FastCmpArc<T> {
    fn top(&self) -> Self {
        FastCmpArc(Arc::new(self.0.top()))
    }

    fn merge(&self, other: &Self) -> Self {
        if Arc::ptr_eq(&self.0, &other.0) {
            self.clone()
        } else {
            FastCmpArc(Arc::new(self.0.merge(&other.0)))
        }
    }
}

impl<T> Deref for FastCmpArc<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}
